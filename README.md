# Helix-Wireless

[Helix](https://github.com/MakotoKurauchi/helix)に[BL652-breakout](https://github.com/ogatatsu/BL652-breakout)
を載せてワイヤレスに改造した物。

## 仕組み
以下の図のようにマスター、スレーブ、PC間で通信する。
![1](./images/1.jpg)

スイッチ１つ１つに一意なIDが振られていて、スレーブマスター間では押されたスイッチのIDを通信でやり取りする、
マスター側では受け取ったスレーブ側で押されたIDと自分側で押されたIDをキーマップからキーコードに変換してPCに送る。
キーマップはマスター側で持っているのでキー配列を変更する時はマスター側のプログラムを変更が必要となる。

![3](./images/3.jpg)

## ビルド方法
- BL652-breakoutには予めFeather nRF52のブートローダーを書き込んでおく。

  参考URL
  
  https://learn.adafruit.com/bluefruit-nrf52-feather-learning-guide/flashing-the-bootloader
  https://qiita.com/ogatatsu@github/items/37f4888c885c4e287df1

- BL652-breakoutを右側、左側共にHelix PCBの白枠線内とは逆の方に刺す。(画像の赤い方)
  ![2](./images/2.jpg)

- ArduinoをインストールしてボードマネージャーからFeather nRF52用の物をインストールしておく。

  参考URL

  https://learn.adafruit.com/bluefruit-nrf52-feather-learning-guide/arduino-bsp-setup

- ArduinoのライブラリマネージャからBounce2ライブラリをインストールする。
- Arduino IDEで.inoファイルを開いて右側のボードにはSlave用のファームウェア、左側にはMaster用のファームウェアを書き込む。

## キーカスタマイズ
キーのカスタマイズはマスター側のソースの`keymap.cpp`ファイルを書き換えることでできる。

通常の入力時のカスタマイズは`keymap[]`配列を変更する。

```c++
static Key keymap[] = {
    {1, L(NK(_GRAVE), CK(_SHIFT, _GRAVE), NK(_GRAVE))},
    {2, L(NK(_1), CK(_SHIFT, _1), NK(_1))},
    {3, L(NK(_2), CK(_SHIFT, _2), NK(_2))},
    {4, L(NK(_3), CK(_SHIFT, _3), NK(_3))},
    {5, L(NK(_4), CK(_SHIFT, _4), NK(_4))},
    ...
```

左側の数字は仕組みで説明した一意なID、右側の関数呼び出しはファームウェア内でコマンドと呼ばれる物でこれの組み合わせを変更することでIDを割り当てられたスイッチを押したときの挙動を変更できる。

どのスイッチが何番のIDに割り当てられているかは以下となる。

```
/* ID
   * ,-----------------------------------------.             ,-----------------------------------------.
   * |   1  |   2  |   3  |   4  |   5  |   6  |             |   7  |   8  |   9  |  10  |  11  |  12  |
   * |------+------+------+------+------+------|             |------+------+------+------+------+------|
   * |  13  |  14  |  15  |  16  |  17  |  18  |             |  19  |  20  |  21  |  22  |  23  |  24  |
   * |------+------+------+------+------+------|             |------+------+------+------+------+------|
   * |  25  |  26  |  27  |  28  |  29  |  30  |             |  31  |  32  |  33  |  34  |  35  |  36  |
   * |------+------+------+------+------+------+------+------+------+------+------+------+------+------|
   * |  37  |  38  |  39  |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |  48  |  49  |  50  |
   * |------+------+------+------+------+------+------+------+------+------+------+------+------+------|
   * |  51  |  52  |  53  |  54  |  55  |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |  64  |
   * `-------------------------------------------------------------------------------------------------'
   */
```

## コマンド一覧
### NOPコマンド
```
Command *NOP
```
何もしないコマンド、以下の例では`SW1`を押しても何も起こらない。
```c++
static Key keymap[] = {
    {1, NOP},
};
```

### NKコマンド
```c++
Command *NK(uint8_t keycode)
```
通常キー用のコマンド、以下の例では`SW1`は`A`,`SW2`は`B`,`SW3`は`C`のキーコードを送出する。
(`keycode.h`ファイルにキーコードに対して`_A`などの名前が割り当てられているのでそちらも参照のこと。)
```c++
static Key keymap[] = {
    {1, NK(_A)},
    {2, NK(_B)},
    {3, NK(_C)},
};
```

### MOコマンド
```c++
Command *MO(Modifier modifier)
```
修飾キー用のコマンド、以下の例では`SW1`は`SHIFT`のキーコードを、`SW2`は`CTRL`と`SHIFT`のキーコードを同時に送出する。
修飾キーは`|`演算子で同時押しの組み合わせを表現できる。
```c++
static Key keymap[] = {
    {1, MO(_SHIFT)},
    {2, MO(_CTRL | _SHIFT)},
};
```

### CKコマンド
```c++
Command *CK(Modifier modifier, uint8_t keycode)
```
コンビネーションキー用のコマンド、修飾キーと通常キーの同時押しを表現できる。以下の例は`SW1`は`CTRL+C`、`SW2`は`CTRL+ALT+DELETE`のキーコードを送出する。
```c++
static Key keymap[] = {
    {1, CK(_CTRL, _C)},
    {2, CK(_CTRL | _ALT, _DELETE)},
};
```

### MTコマンド
```c++
Command *MT(Modifier modifier, uint8_t keycode)
```
スイッチを押した後リリースせずにに別のスイッチを押したときは第1引数の修飾キー、スイッチ単体でタップすると第2引数の通常キーとして機能するコマンド、以下の例で`SW1`を押した後離さずに`SW2`を押すと`SHIFT`キー（結果として`SHIFT+A`）、`SW1`を押して何もせずにそのまま離すと`SPACE`キーのキーコードが送出される。
```c++
static Key keymap[] = {
    {1, MT(_SHIFT, _SPACE)},
    {2, NK(_A)},
};
```

### OSMコマンド
```c++
Command *OSM(Modifier modifier)
```
スイッチを押して離すと次にスイッチを押した時に送出されるキーコードと同時に引数の修飾キーも送出される、スイッチを押して離さずに別のスイッチを押した場合は通常の修飾キーコマンドの様に動作する。下の例では`SW1`を押して離した後に`SW2`を押すと`SHIFT+A`のキーコードが送出される。
```c++
static Key keymap[] = {
    {1, OSM(_SHIFT)},
    {2, NK(_A)},
};
```

### Lコマンド
```c++
Command *L(Command *first, Commands... rest)
```
レイヤーコマンド、現在のレイヤーによって動作させるコマンドを変更する。以下の例では`SW1`を押すと現在のレイヤーが0の時は`A`、レイヤーが1の時は`B`、レイヤーが2の時は`C`のキーコードを送出する。
```c++
static Key keymap[] = {
    {1, L(NK(_A), NK(_B), NK(_C))},
};
```

### SLコマンド
```c++
Command *SL(uint8_t layerNumber)
```
スイッチを押してる間だけ引数の番号のレイヤーをONにする。以下の例では`SW1`単体で押すと`A`、`SW2`を押しながら`SW1`を押すと`B`、`SW3`を押しながら`SW1`を押すと`C`のキーコードを送出する。レイヤー番号の数字が高いほうのコマンドが優先されるので`SW2`と`SW3`を同時に押しながら`SW1`を押すと`SW3`のレイヤー番号の`2`が優先され`C`のキーコードが送出される。
```c++
static Key keymap[] = {
    {1, L(NK(_A), NK(_B), NK(_C))},
    {2, SL(1)},
    {3, SL(2)},
};
```

### TLコマンド
```c++
Command *TL(uint8_t layerNumber)
```
スイッチを押したら引数の番号のレイヤーをトグルする、SLコマンドと違いスイッチを離したあとでもレイヤーをONにし続ける事ができる。以下の例だと１回`SW2`を押すとレイヤー1がONになりその状態で`SW1`を押すと`A`のキーコードを送出する。もう１回`SW2`を押すとレイヤー1がONからOFFに変わりその状態で`SW1`を押すと`B`のキーコードを送出する。
```c++
static Key keymap[] = {
    {1, L(NK(_A), NK(_B))},
    {2, TL(1)},
};
```
続く
